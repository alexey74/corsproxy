#!/usr/bin/python -u
"""
Provides a simple CORS proxy for GET and POST requests. Reads list of
target port:host[:targetport] from the command line, or from your config
file.
"""
import argparse
import os
from pathlib import Path
import signal
import sys


from gevent import monkey


monkey.patch_all()  # noqa :E702

import requests  # @NoMove

from bottle import Bottle, request, response  # @NoMove

# Get location of optional conf file
PROG = Path(sys.argv[0]).stem
CONFFILE = Path(os.getenv("XDG_CONFIG_HOME", "~/.config")).expanduser() / PROG


def check_targets(targets):
    "Do some sanity checking on user specified target mappings"
    ports = set()
    for t in targets:
        if ":" not in t:
            sys.exit('Require port:host in entry "{}"'.format(t))
        vals = t.split(":")
        if len(vals) > 3:
            sys.exit('Invalid entry "{}"'.format(t))
        port = vals[0]
        if port in ports:
            sys.exit("Listening port {} specified more than once".format(port))
        ports.add(port)


# Process command line options
opt = argparse.ArgumentParser(description=__doc__.strip())
opt.add_argument(
    "targets",
    nargs="*",
    help="1 or more proxy target hosts in port:host[:targetport] "
    "format. if not set then will try to read from "
    "~/.config/{} file.".format(PROG),
)
args = opt.parse_args()

targets = args.targets

if not targets:
    if CONFFILE.exists():
        targets = CONFFILE.read_text().strip().split()
    if not targets:
        opt.error("No target host mappings defined")

check_targets(targets)

app = Bottle()

mytarget = None

METHODS = ["GET", "POST", "OPTIONS"]
POST_HEADERS = {
    "Access-Control-Allow-Methods": ", ".join(METHODS),
    "Access-Control-Allow-Headers": ", ".join(
        [
            "Content-Type",
            "Content-Length",
            "mime-version",
            "Access-Control-Allow-Headers",
            "Authorization",
            "X-Requested-With",
        ]
    ),
    "Access-Control-Allow-Credentials": "true",
}


@app.get("/<path:path>", method=METHODS)
def get(path):
    origin = os.getenv("ORIGIN", "*")
    print("origin:", origin)
    response.set_header("Access-Control-Allow-Origin", origin)

    qstring = request.query_string
    qstring = ("?" + qstring) if qstring else ""
    path = ("/" + path) if path else ""
    url = "{}://{}{}{}".format(request.urlparts[0], mytarget, path, qstring)
    ct = request.content_type
    header = {"Content-Type": ct} if ct else {}

    for k, v in request.headers.items():
        if k.lower() not in ["host", "etag", "if-none-match"]:
            header[k] = v

    for k, v in POST_HEADERS.items():
        if k.lower() == "transfer-encoding" and v.lower() == "chunked":
            continue
        response.set_header(k, v)

    print(">> rq:", request)
    for k, v in header.items():
        print(">> h:", k, ": ", v)

    if request.method == "GET":
        r = requests.get(url, headers=header)
    else:

        if request.method == "OPTIONS":
            return

        data = request.body.read()
        print(">> data:", data)
        assert len(data) == int(header["Content-Length"])

        r = requests.post(url, data=data, headers=header)

    print("<<<", r.headers)
    for key in r.headers:
        if key.lower() == "transfer-encoding" and r.headers[key].lower() == "chunked":
            continue
        if key.lower() != "Access-Control-Allow-Origin".lower():
            response.set_header(key, r.headers[key])

    response.status = r.status_code
    print("<< resp:", r.status_code, "text:", r.text)
    return r.text


@app.get("/", method=METHODS)
def getroot():
    return get(None)


def run(target):
    global mytarget

    signal.signal(signal.SIGINT, lambda *args: sys.exit(0))

    port, host = target.split(":", maxsplit=1)
    mytarget = host
    print("Starting proxy for {} -> {}".format(port, host))
    app.run(host="0.0.0.0", port=port, server="gevent", quiet=True)


# Just run in same process if we only have a single proxy service
# configured. Otherwise create and start a process for each service.
if len(targets) > 1:
    import multiprocessing

    for t in targets:
        multiprocessing.Process(target=run, args=(t,)).start()

    for p in multiprocessing.active_children():
        p.join()
else:
    run(targets[0])
